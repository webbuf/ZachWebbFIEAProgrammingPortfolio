This is a (simplified) simulation of how an OS manages memory written in C++. I chose to include it because it has some work with data structures and algorithmic paradigms. It also makes use of standard POSIX calls and C functions like malloc, so it's working at a slightly closer to OS level than I'm used to. I'm also happy with how thoroughly commented and explained it is. It allocates a chunk of memory with new once on initialization, and then distributes that out to fictional processes that want some of the memory. It uses an ordered map to track the holes of currently free memory, and uses a few functions (best fit and worst fit) to determine which hole to allocate. It then modifies its hole list for the next request. Processes are given a pointer to the start of their memory. When a process wants to free its memory, it gives back a pointer anywhere within the space reserved for it. It also contains multiple ways of expressing the current hole structure, a bitfield and a dump to a text file. 

To compile, simply run make in this directory. This generates a test.exe file within this directory. 

CommandLineTest.cpp was NOT WRITTEN BY ME. The MemoryManager files are the part written by me. CommandLineTest was provided by the staff of the course to test our project. I've included it so there's something to run, as the MemoryManager itself is just a data structure library and doesn't do anything on its own. CommandLineTest will run through all functionality of the project and test it, scoring it based off of everything it does correctly. On it's own, it's just a set of tests. 